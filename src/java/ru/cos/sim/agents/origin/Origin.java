package ru.cos.sim.agents.origin;

import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Set;

import ru.cos.cs.lengthy.Observation;
import ru.cos.sim.agents.AbstractRoadAgent;
import ru.cos.sim.driver.composite.Obstacle;
import ru.cos.sim.engine.RoadNetworkUniverse;
import ru.cos.sim.road.link.Lane;
import ru.cos.sim.road.link.Link;
import ru.cos.sim.road.node.OriginNode;
import ru.cos.sim.road.objects.RoadObject;
import ru.cos.sim.utils.Triplet;
import ru.cos.sim.vehicle.Vehicle;

/**
 * Origin creates instances of vehicles, places them on the road
 * and revive them to live in simulation process.<br/>
 * Origin generates external traffic flow from outside of the road network
 * model. In real life traffic flows may vary, origins allow to model variations
 * of generated traffic flows.
 * Behavior of the origin divided into one or more time periods. In each period
 * origin generates traffic flow with uniform characteristics like traffic flow intensity,
 * distribution of vehicles between destination nodes, distribution of vehicles between
 * specific vehicle types and other.
 * <p>
 * To create consistent and viable origin agent it is required to initialize its following 
 * properties:
 * <li> {@link #originNode}
 * <li> {@link #universe}
 * <li> {@link #periods}
 * 
 * @author zroslaw
 */
public class Origin extends AbstractRoadAgent {
	
	/**
	 * Origin node from which this origin will generate traffic flow
	 */
	private OriginNode originNode;
	
	private RoadNetworkUniverse universe;
	
	private List<OriginPeriod> periods;
	
	private OriginPeriod currentPeriod;
	
	private Queue<Vehicle> originatedVehiclesQueue = new LinkedList<Vehicle>();
	
	/**
	 * Minimum distance to release vehicle on the road.<br>
	 * Value of this parameter is based on the intention to 
	 * maximize intensity of vehicle generation.<br>
	 * If we consider typical traffic diagram (density-flow) we 
	 * will see that maximum traffic flow reached with density about 40-50 veh/km
	 * (of course it may vary, but generally).<br>
	 * So to maximize traffic flow generated by origin we must 
	 * originate vehicles with density 40-50 veh/km.
	 */
	public static final float RELEASE_DISTANCE = 1000.f/50.f;
	
	public static final float RELEASE_SPEED = 30.f*1000.f/3600.f; // 30 km/hr

	@Override
	public void act(float dt) {
		
		if (periods.size()<=0 && originatedVehiclesQueue.isEmpty()){
			isAlive = false;
			return;
		}
		
		if (currentPeriod==null) currentPeriod = periods.get(0);
		
		// check if end of time period is reached
		if (!currentPeriod.isActive() && !periods.isEmpty()){
			periods.remove(0);
			if (periods.size()<=0) return;
			currentPeriod = periods.get(0);
			currentPeriod.init();
		}
		
		// Delegate function of creating new vehicles 
		// to the current origin period instance
		Set<Vehicle> originatedVehicles = currentPeriod.originateVehicles(dt);
		
		// put vehicles in the queue of new vehicles
		originatedVehiclesQueue.addAll(originatedVehicles);
		
		// try to release originated vehicles from the queue to the road 
		// and bring them to live as agents in the system
		releaseVehicles();
		
	}

	private void releaseVehicles() {
		if (originatedVehiclesQueue.size()==0) return;
		
		// find free lanes in the beginning of outgoing link
		Link outgoingLink = originNode.getOutgoingLink();
		Lane[] lanes = outgoingLink.getFirstSegment().getLanes();
		
		// Generate information about free lanes
		List<Triplet<Integer, Float, RoadObject>> freeLanes = findFreeLanes();
		
		// for each free lane release a vehicle from the queue
		for (Triplet<Integer, Float, RoadObject> freeLaneData:freeLanes){
			// retrieve first vehicle in the queue
			Vehicle vehicle = originatedVehiclesQueue.peek();
			if (vehicle==null) return; // return if no more vehicles in the queue
			
			// check if distance is enough for the vehicle
			float freeDistance = freeLaneData.getSecond();
			if (freeDistance<vehicle.getHalfLength()+2.0f) // plus free distance of 2 meters
				break; // there is not enough free space for current vehicle
			
			// check that release distance is kept
			if (freeDistance>RELEASE_DISTANCE){
				// remove vehicle from the queue
				originatedVehiclesQueue.poll();
				// put it in the beginning of appropriate lane
				Lane lane = lanes[freeLaneData.getFirst()];
				lane.putPoint(vehicle, 0);
				// set speed
				vehicle.setSpeed(RELEASE_SPEED);
				// bring vehicle to live as agent in the system
				universe.addNewborn(vehicle);
			}else{
				// release distance is not kept 
				// so we can break iterations, because of 
				// all other distances are smaller than that
				break;
			}
				
		}
		
	}

	/**
	 * Find information about free lanes.<br>
	 * Information about free lane it is a triplet of following values:
	 * <ol>
	 * 	<li>lane index</li>
	 *  <li>free distance from the beginning of the lane</li>
	 *  <li>road object that is obstacle for the vehicle</li>
	 * </ol>
	 * List is in descended order based on free lane distance
	 * @return order list of triplets that describe information about free lanes
	 */
	private List<Triplet<Integer, Float, RoadObject>> findFreeLanes() {
		List<Triplet<Integer, Float, RoadObject>> freeLanes = new LinkedList<Triplet<Integer,Float,RoadObject>>();

		// iterate through all beginning lanes of outgoing link
		Lane[] lanes = originNode.getOutgoingLink().getFirstSegment().getLanes();
		for (Lane lane:lanes){
			// observe each lane from the beginning on the distance of RELEASE_DISTANCE
			List<Observation> observations = lane.observeForward(0, RELEASE_DISTANCE, null);
			// construct default free lane information triplet instance
			Triplet<Integer, Float, RoadObject> freeLane = 
				new Triplet<Integer, Float, RoadObject>(lane.getIndex(), RELEASE_DISTANCE+1, null);
			// iterate through lane observations and find obstacles among them
			for (Observation observation:observations){
				RoadObject roadObject = (RoadObject)observation.getPoint();
				if (Obstacle.getObstacleType(roadObject)!=null){
					freeLane.setSecond(observation.getDistance());
					freeLane.setThird(roadObject);
					break;
				}
			}
			freeLanes.add(freeLane);
		}
		
		// sort list in descend order
		Collections.sort(freeLanes, new Comparator<Triplet<Integer, Float, RoadObject>>() {
			@Override
			public int compare(Triplet<Integer, Float, RoadObject> arg0,
					Triplet<Integer, Float, RoadObject> arg1) {
				return -arg0.getSecond().compareTo(arg1.getSecond());
			}
		});
		
		return freeLanes;
	}

	public OriginNode getOriginNode() {
		return originNode;
	}

	public void setOriginNode(OriginNode originNode) {
		this.originNode = originNode;
	}

	public void setUniverse(RoadNetworkUniverse universe) {
		this.universe = universe;
	}

	public void setPeriods(List<OriginPeriod> periods) {
		this.periods = periods;
	}

	@Override
	public final TrafficAgentType getTrafficAgentType() {
		return TrafficAgentType.Origin;
	}

}
