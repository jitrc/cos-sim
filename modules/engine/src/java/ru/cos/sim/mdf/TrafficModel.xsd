<?xml version="1.0" encoding="UTF-8"?>
<schema xmlns="http://www.w3.org/2001/XMLSchema"
	targetNamespace="http://traffic.cos.ru/cossim/TrafficModelDefinitionFile0.1"
	xmlns:tns="http://traffic.cos.ru/cossim/TrafficModelDefinitionFile0.1"
	elementFormDefault="qualified">

	<element name="TrafficModel">
		<annotation>
			<documentation>
				Traffic Model Definition for COS.SIM - agent based
				traffic micro-simulation software.
				Model definition consist of
				definition of ru.cos.sim.visualizer.sim.road network,
				set of predefined ru.cos.sim.visualizer.sim.agents and set of
				installed meters.
			</documentation>
		</annotation>
		<complexType>
			<sequence>
				<element name="RoadNetwork" type="tns:RoadNetwork">
					<annotation>
						<documentation>
							Definition of the particular ru.cos.sim.visualizer.sim.road network.
							Road network on the top level consists
							of links and nodes. Each link
							always connects two nodes and
							represents one-way ru.cos.sim.visualizer.sim.road. Nodes
							represent intersections. Each node
							connects any number of links.
						</documentation>
					</annotation>
				</element>
				<element name="Agents">
					<annotation>
						<documentation>
							Set of predefined ru.cos.sim.visualizer.sim.agents of the model.
							Predefined ru.cos.sim.visualizer.sim.agents are ru.cos.sim.visualizer.sim.agents that is defined 
							in the beginning of simulation process, they 
							are alive and active. Contrary, there are 
							ru.cos.sim.visualizer.sim.agents that are born during simulation process.
							There are possible following types of predefined
							ru.cos.sim.visualizer.sim.agents: Origins, Vehicles and Traffic Light Networks.
						</documentation>
					</annotation>
					<complexType>
						<all>
							<element name="Origins" minOccurs="0">
								<annotation>
									<documentation>
										Set of model origins.
									</documentation>
								</annotation>
								<complexType>
									<sequence>
										<element name="Origin" type="tns:Origin" maxOccurs="unbounded" />
									</sequence>
								</complexType>
							</element>
							<element name="Vehicles" minOccurs="0">
								<annotation>
									<documentation>
										Set of predefined vehicles on the ru.cos.sim.visualizer.sim.road network.
									</documentation>
								</annotation>
								<complexType>
									<choice maxOccurs="unbounded">
										<element name="RegularVehicle" type="tns:RegularVehicleAgent"/>
									</choice>
								</complexType>
							</element>
							<element name="TrafficLightNetworks" minOccurs="0">
								<annotation>
									<documentation>
										Set of traffic light networks on the ru.cos.sim.visualizer.sim.road network.
										Traffic Light Network is a set of coordinated behaving
										traffic lights on a particular node. There three
										types of traffic light networks are available:
										Regular and PeakAware.
									</documentation>
								</annotation>
								<complexType>
									<choice maxOccurs="unbounded">
										<element name="RegularTrafficLightNetwork" type="tns:RegularTrafficLightNetwork"/>
										<element name="PeakAwareTrafficLightNetwork" type="tns:PeakAwareTrafficLightNetwork"/>
									</choice>
								</complexType>
							</element>
						</all>
					</complexType>
				</element>
				<element name="Meters" minOccurs="0">
					<annotation>
						<documentation>
							Set of installed meters in the model.
							There are possible 4 types of global meters,
							meters that measure data for entire simulation process:
							InstantAverageSpeedMeter, NetworkAverageTravelSpeedMeter,
							TotalTravelTimeMeter, AverageTravelTimeMeter.
							And 7 types of local meters, that collect data for 
							a specific ru.cos.sim.visualizer.sim.road network location:
							LinkAverageTravelSpeedMeter, SectionAverageTravelSpeedMeter,
							SectionAverageTravelSpeedMeter, TrafficVolumeMeter,
							DensityMeter, FlowMeter, DensityFlowMeter and
							VehiclesAppearanceHeadwayMeter.
						</documentation>
					</annotation>
					<complexType>
						<choice maxOccurs="unbounded" minOccurs="0">
							<element name="InstantAverageSpeedMeter" type="tns:InstantAverageSpeedMeter"
								minOccurs="0" maxOccurs="1" />
							<element name="NetworkAverageTravelSpeedMeter" type="tns:NetworkAverageTravelSpeedMeter"
								minOccurs="0" maxOccurs="1" />
							<element name="TotalTravelTimeMeter" type="tns:TotalTravelTimeMeter"
								minOccurs="0" maxOccurs="1" />
							<element name="AverageTravelTimeMeter" type="tns:AverageTravelTimeMeter"
								minOccurs="0" maxOccurs="1" />
							<element name="LinkAverageTravelSpeedMeter" type="tns:LinkAverageTravelSpeedMeter"
								minOccurs="0" maxOccurs="unbounded" />
							<element name="SectionAverageTravelSpeedMeter" type="tns:SectionAverageTravelSpeedMeter"
								minOccurs="0" maxOccurs="unbounded" />
							<element name="TrafficVolumeMeter" type="tns:TrafficVolumeMeter"
								minOccurs="0" maxOccurs="unbounded" />
							<element name="DensityMeter" type="tns:DensityMeter"
								minOccurs="0" maxOccurs="unbounded" />
							<element name="FlowMeter" type="tns:FlowMeter" minOccurs="0"
								maxOccurs="unbounded" />
							<element name="DensityFlowMeter" type="tns:DensityFlowMeter"
								minOccurs="0" maxOccurs="unbounded" />
							<element name="VehiclesAppearanceHeadwayMeter" type="tns:VehiclesAppearanceHeadwayMeter"
								minOccurs="0" maxOccurs="unbounded" />
						</choice>
					</complexType>
				</element>
			</sequence>
		</complexType>
	</element>

	<complexType name="RoadNetwork">
		<all>
			<element name="Links">
				<annotation>
					<documentation>
						Set of links in the ru.cos.sim.visualizer.sim.road network.
									</documentation>
				</annotation>
				<complexType>
					<sequence>
						<element name="Link" type="tns:Link" maxOccurs="unbounded" />
					</sequence>
				</complexType>
			</element>
			<element name="Nodes">
				<annotation>
					<documentation>
						"Nodes" element contains definitions of all
						nodes of the ru.cos.sim.visualizer.sim.road network. There are three possible types of
						the nodes: RegularNode, OriginNode and DestinationNode.
						At least two nodes must be presented in the model
						definition (source and destination of single link).
										</documentation>
				</annotation>
				<complexType>
					<choice maxOccurs="unbounded" minOccurs="2">
						<element name="RegularNode" type="tns:RegularNode" />
						<element name="OriginNode" type="tns:OriginNode" />
						<element name="DestinationNode" type="tns:DestinationNode" />
					</choice>
				</complexType>
			</element>
		</all>
	</complexType>

	<complexType name="Link">
		<annotation>
			<documentation>
				Link of the ru.cos.sim.visualizer.sim.road network. Link connects two nodes
				and represents one-way ru.cos.sim.visualizer.sim.road between two intersections
				(nodes represent intersections). Link consists of
				sequentially placed link's segments, link's segment is
				a segment of the ru.cos.sim.visualizer.sim.road with uniform geometry.
			</documentation>
		</annotation>
		<sequence>
			<element name="id" type="nonNegativeInteger">
				<annotation>
					<documentation>
						Unique id of the link in the ru.cos.sim.visualizer.sim.road network model.
					</documentation>
				</annotation>
			</element>
			<element name="name" type="string" minOccurs="0">
				<annotation>
					<documentation>
						Optional human readable name of the link.
					</documentation>
				</annotation>
			</element>
			<element name="sourceNodeId" type="nonNegativeInteger">
				<annotation>
					<documentation>
						Identifier of the source node of this link.
					</documentation>
				</annotation>
			</element>
			<element name="destinationNodeId" type="nonNegativeInteger">
				<annotation>
					<documentation>
						Identifier of the destination node of this link.
					</documentation>
				</annotation>
			</element>
			<element name="length" type="tns:positiveFloat">
				<annotation>
					<documentation>
						Length of the link. Length is calculated as a sum
						of lengths of all link's segments.
					</documentation>
				</annotation>
			</element>
			<element name="Segments">
				<annotation>
					<documentation>
						List of link's segments.
					</documentation>
				</annotation>
				<complexType>
					<choice maxOccurs="unbounded">
						<element name="TrapeziumSegment" type="tns:TrapeziumSegment" />
					</choice>
				</complexType>
			</element>
			<element name="Waypoints">
				<annotation>
					<documentation>
						Waypoints are points where segments connects with each other, 
						points in the beginning and in the end of each segment.
						Because ru.cos.sim.visualizer.sim.road segments have width, such waypoints are treated
						to be in the center on connected segments butts.
						Waypoints are required for software that deals with ru.cos.sim.visualizer.sim.road
						network construction and editing and are optional for
						simulation engine and visualization.
					</documentation>
				</annotation>
				<complexType>
					<sequence>
						<element name="Waypoint" type="tns:Waypoint" maxOccurs="unbounded" />
					</sequence>
				</complexType>
			</element>
		</sequence>
	</complexType>

	<complexType name="Waypoint">
		<annotation>
			<documentation>
				Waypoint is a point on the plane with specified id.
			</documentation>
		</annotation>
		<sequence>
			<element name="id" type="nonNegativeInteger" />
			<element name="x" type="float" />
			<element name="y" type="float" />
		</sequence>
	</complexType>

	<complexType name="RoadSegment">
		<annotation>
			<documentation>
				Road Segment is segment of the ru.cos.sim.visualizer.sim.road with uniform geometry.
				Geometry considered as uniform if it can be treated as 
				one of the simple geometric curves: line, circle arc,
				Bezier curve or other.
				Road Segment consists of array of parallel lanes, it 
				connects with previous and next segments and on the
				segment it is possible to place ru.cos.sim.visualizer.sim.road signs.
			</documentation>
		</annotation>
		<sequence>
			<element name="id" type="nonNegativeInteger">
				<annotation>
					<documentation>
						Unique id of the segment in the link.
					</documentation>
				</annotation>
			</element>
			<element name="length" type="tns:positiveFloat">
				<annotation>
					<documentation>
						Length of the segment is treated as length of 
						the last left of it's lane.
					</documentation>
				</annotation>
			</element>
			<element name="prevSegmentId" type="tns:referenceId">
				<annotation>
					<documentation>
						Id of the previous segment.
						Or -1 in case there is no previous segment (when this segment is first in the link).
					</documentation>
				</annotation>
			</element>
			<element name="nextSegmentId" type="tns:referenceId">
				<annotation>
					<documentation>
						Id of the next segment.
						Or -1 in case there is no next segment (when this segment is last in the link).
					</documentation>
				</annotation>
			</element>
			<element name="Lanes">
				<annotation>
					<documentation>
						Array of lanes that makes up the segment. 
						Lanes are ordered by their indexes. Leftmost 
						lane has index equals to 0, rightmost has 
						highest index in the segment.
					</documentation>
				</annotation>
				<complexType>
					<sequence>
						<element name="Lane" type="tns:Lane" maxOccurs="unbounded"/>
					</sequence>
				</complexType>
			</element>
			<element name="RoadSigns" minOccurs="0">
				<annotation>
					<documentation>
						Set of ru.cos.sim.visualizer.sim.road signs installed on this segment.
						Installed on the segment are visible on each lane of 
						this segment.
						To install ru.cos.sim.visualizer.sim.road sign on the segment it is required to specify
						exact position of the sign. Position of the sign is treated 
						as position on leftmost lane and for righter lanes it will
						be propagated with corresponded adjacent positions. 
					</documentation>
				</annotation>
				<complexType>
					<choice maxOccurs="unbounded">
						<element name="SpeedLimitSign">
							<annotation>
								<documentation>
									Installed speed limit sign.
								</documentation>
							</annotation>
							<complexType>
								<sequence>
									<element name="position" type="tns:positiveFloat" />
									<element name="speedLimit" type="tns:positiveFloat" />
								</sequence>
							</complexType>
						</element>
						<element name="NoSpeedLimitSign">
							<annotation>
								<documentation>
									Installed sign that cancels all previous speed limits.
								</documentation>
							</annotation>
							<complexType>
								<sequence>
									<element name="position" type="tns:positiveFloat" />
								</sequence>
							</complexType>
						</element>
					</choice>
				</complexType>
			</element>
		</sequence>
	</complexType>

	<complexType name="TrapeziumSegment">
		<annotation>
			<documentation>
				Road Segment is segment of the ru.cos.sim.visualizer.sim.road with uniform geometry.
				Geometry considered as uniform if it can be treated as 
				one of the simple geometric curves: line, circle arc,
				Bezier curve or other.
				Line(segment of line) is a simplest curve.
				Combining several lines with different length we can model any
				other geometry figure. Segment line has no width, but ru.cos.sim.visualizer.sim.road segment do.
				To smoothly connect ru.cos.sim.visualizer.sim.road segments we need to extend figure to the trapezium,
				where left and right sides of the ru.cos.sim.visualizer.sim.road are trapezium bases (the are parallel)
				and butts of the segment are trapezium sides.
				So simplest segment geometry is trapezium geometry and for now it is the only
				possible Road Segment type.
			</documentation>
		</annotation>
		<complexContent>
			<extension base="tns:RoadSegment">
				<sequence>
					<element name="trapeziumShift" type="float">
						<annotation>
							<documentation>
								Trapezium shift is a distance between beginning of
								leftmost lane and projection of beginning of rightmost
								lane on leftmost lane. Distance is measured in the
								segment's direction and may be negative and positive.
								Parameter is required for Simulation Engine to calculate
								adjacent position of neighbouring lanes.
							</documentation>
						</annotation>
					</element>
					<element name="TrapeziumGeometry" type="tns:Trapezium">
						<annotation>
							<documentation>
								Definition of the trapezium shape of this ru.cos.sim.visualizer.sim.road segment. 
							</documentation>
						</annotation>
					</element>
				</sequence>
			</extension>
		</complexContent>
	</complexType>

	<complexType name="Trapezium">
		<annotation>
			<documentation>
				Definition of the trapezium on the plane.
			</documentation>
		</annotation>
		<sequence>
			<element name="LeftSide" type="tns:LineSegment">
				<annotation>
					<documentation>
						Actually not a side, but one of the trapezium base.
						Name LeftSide is used because this base is left side of a
						trapezium ru.cos.sim.visualizer.sim.road segment.
					</documentation>
				</annotation>
			</element>
			<element name="RightSide" type="tns:LineSegment">
				<annotation>
					<documentation>
						Actually not a side, but one of the trapezium base.
						Name RightSide is used because this base is right side of a
						trapezium ru.cos.sim.visualizer.sim.road segment.
					</documentation>
				</annotation>
			</element>
		</sequence>
	</complexType>

	<complexType name="Point">
		<annotation>
			<documentation>
				Point on the plane with X and Y coordinates.
			</documentation>
		</annotation>
		<sequence>
			<element name="x" type="float" />
			<element name="y" type="float" />
		</sequence>
	</complexType>

	<complexType name="LineSegment">
		<annotation>
			<documentation>
				Definition of line segment. Line segment has start and end points. 
			</documentation>
		</annotation>
		<sequence>
			<element name="Start" type="tns:Point" />
			<element name="End" type="tns:Point" />
		</sequence>
	</complexType>

	<complexType name="Lane">
		<annotation>
			<documentation>
				Definition of the ru.cos.sim.visualizer.sim.road segment's lane.
			</documentation>
		</annotation>
		<sequence>
			<element name="index" type="nonNegativeInteger">
				<annotation>
					<documentation>
						Index of the lane in the segment's lanes array.
						Lanes are ordered by their indexes. Leftmost 
						lane has index equals to 0, rightmost has 
						highest index in the segment
					</documentation>
				</annotation>
			</element>
			<element name="length" type="tns:positiveFloat">
				<annotation>
					<documentation>
						Length of the lane. 
					</documentation>
				</annotation>
			</element>
			<element name="width" type="tns:positiveFloat">
				<annotation>
					<documentation>
						Width of the lane. 
					</documentation>
				</annotation>
			</element>
			<element name="prevLaneIndex" type="tns:referenceId">
				<annotation>
					<documentation>
						Index of the previous lane in the previous segment.
						If there is no trajectory on the previous segment that
						leads to this lane (lane is just opens, next segment 
						has one lane less than this segment) or in case 
						when it is the first segment in the link (and therefore 
						no previous lane and next), then prevLaneIndex must beset to -1.
					</documentation>
				</annotation>
			</element>
			<element name="nextLaneIndex" type="tns:referenceId">
				<annotation>
					<documentation>
						Index of the next lane in the next segment.
						If there is no lane trajectory continuation on 
						the next segment (lane is closing, next segment 
						has one lane less than this segment) or in case 
						when it is the last segment in the link (and therefore 
						no next lane and next), then nextLaneIndex must be set to -1.
					</documentation>
				</annotation>
			</element>
		</sequence>
	</complexType>

	<complexType name="Node">
		<annotation>
			<documentation>
				Abstract node data type.
			</documentation>
		</annotation>
		<sequence>
			<element name="id" type="nonNegativeInteger">
				<annotation>
					<documentation>
						Unique node id in the ru.cos.sim.visualizer.sim.road network.
					</documentation>
				</annotation>
			</element>
			<element name="name" type="string" minOccurs="0">
				<annotation>
					<documentation>
						Human readable name of the node. Name is optional.
					</documentation>
				</annotation>
			</element>
		</sequence>
	</complexType>

	<complexType name="RegularNode">
		<annotation>
			<documentation>
				Regular node of the ru.cos.sim.visualizer.sim.road network.
				Node that connects several links, through 
				regular node vehicles can pass from one 
				link to another therefore navigating on the
				ru.cos.sim.visualizer.sim.road network. 
				Regular node defines trajectories (called 
				transition rules) which vehicles must obey
				when they are pass through the node.
				Because even for simple intersection there 
				are a lot of particular trajectories 
				(transition rules) it is make sense to organize
				them in the groups to easy operate them.
				Such group of transition rules are called
				Turn Transition Rules Groups (or TurnTRGroup).
				"Turn" in the group name means that all transition
				rules in the group are performing one "turn" or
				one pass through the node from one specified link to 
				another specified link.
				For transition rules in the TurnTRGroup it is possible to
				perform collective operations such as defining geometry
				(on the base of Bezier curve) and placing traffic lights 
				on the beginning of each transition rule.
			</documentation>
		</annotation>
		<complexContent>
			<extension base="tns:Node">
				<sequence>
					<element name="TransitionRules" minOccurs="0">
						<annotation>
							<documentation>
								Set of transition rules of the node.
							</documentation>
						</annotation>
						<complexType>
							<sequence>
								<element name="TransitionRule" type="tns:TransitionRule"
									maxOccurs="unbounded" minOccurs="0" />
							</sequence>
						</complexType>
					</element>
					<element name="TurnTRGroups" minOccurs="0">
						<annotation>
							<documentation>
								Set of Turn Transition Rules Groups of the node.
							</documentation>
						</annotation>
						<complexType>
							<sequence>
								<element name="TurnTRGroup" type="tns:TurnTRGroup"
									maxOccurs="unbounded" minOccurs="0" />
							</sequence>
						</complexType>
					</element>
					<choice>
						<annotation>
							<documentation>
								Geometry of the node may have different types.
								Simplest node geometry is a polygon.
							</documentation>
						</annotation>
						<element name="PolygonGeometry" type="tns:Polygon" />
					</choice>
				</sequence>
			</extension>
		</complexContent>
	</complexType>

	<complexType name="Polygon">
		<annotation>
			<documentation>
				Type defines polygon on the plane.
				Minimum number of points in the polygon is 3.
			</documentation>
		</annotation>
		<sequence>
			<element name="Point" type="tns:Point" maxOccurs="unbounded"
				minOccurs="3" />
		</sequence>
	</complexType>

	<complexType name="TurnTRGroup">
		<annotation>
			<documentation>
				Because even for simple intersection there 
				are a lot of particular trajectories 
				(transition rules) it is make sense to organize
				them in the groups to easy operate them.
				Such group of transition rules are called
				Turn Transition Rules Groups (or TurnTRGroup).
				"Turn" in the group name means that all transition
				rules in the group are performing one "turn" or
				one pass through the node from one specified link to 
				another specified link.
				For transition rules in the TurnTRGroup it is possible to
				perform collective operations such as defining geometry
				(on the base of Bezier curve) and placing traffic lights 
				on the beginning of each transition rule.
			</documentation>
		</annotation>
		<sequence>
			<element name="id" type="nonNegativeInteger">
				<annotation>
					<documentation>
						Unique id of the TurnTRGroup in the node.
					</documentation>
				</annotation>
			</element>
			<element name="name" type="string">
				<annotation>
					<documentation>
						Human readable name of the TurnTRGroup.
					</documentation>
				</annotation>
			</element>
			<element name="BaseBezierCurve" type="tns:CubicBezierCurve">
				<annotation>
					<documentation>
						Base Bezier curve for all transition rules 
						which geometry is controlled by this TurnTRGroup.
						This Bezier curve defines overall shape of the "turn" pass,
						while each particular TR geometry has its own unique shape. 
						(Note there are possible transition rules in the
						TurnTRGroup which geometry are not controlled by
						this base curve).
						This curve is generally for ru.cos.sim.visualizer.sim.road editing and 
						constructing software, because only this software 
						make changes in a particular TR geometry according
						to this curve.
					</documentation>
				</annotation>
			</element>
			<element name="TransitionRules">
				<annotation>
					<documentation>
						Set of transition rules that are in this group.
					</documentation>
				</annotation>
				<complexType>
					<sequence>
						<element name="TransitionRule" maxOccurs="unbounded">
							<complexType>
								<sequence>
									<element name="transitionRuleId" type="nonNegativeInteger">
										<annotation>
											<documentation>
												Transition rule id.
											</documentation>
										</annotation>
									</element>
									<element name="controlledByTurnTRGroup" minOccurs="0">
										<annotation>
											<documentation>
												Flag element that, if it exists, specifies that
												geometry of transition rule is controlled by TurnTRGroup.
											</documentation>
										</annotation>
									</element>
								</sequence>
							</complexType>
						</element>
					</sequence>
				</complexType>
			</element>
		</sequence>
	</complexType>

	<complexType name="CubicBezierCurve">
		<annotation>
			<documentation>
				Cubic Bezier curve based on 4 reference points.
			</documentation>
		</annotation>
		<sequence>
			<element name="ReferencePoints">
				<complexType>
					<sequence>
						<element name="Point" type="tns:Point" minOccurs="4"
							maxOccurs="4" />
					</sequence>
				</complexType>
			</element>
		</sequence>
	</complexType>

	<complexType name="TransitionRule">
		<annotation>
			<documentation>
				Regular node's transition rule.
			</documentation>
		</annotation>
		<sequence>
			<element name="id" type="nonNegativeInteger">
				<annotation>
					<documentation>
						Unique transition rule id in the node.
					</documentation>
				</annotation>
			</element>
			<element name="length" type="tns:positiveFloat">
				<annotation>
					<documentation>
						Length of the trajectory of the transition rule.
					</documentation>
				</annotation>
			</element>
			<element name="width" type="tns:positiveFloat">
				<annotation>
					<documentation>
						Width of the transition rule.
					</documentation>
				</annotation>
			</element>
			<element name="sourceLinkId" type="nonNegativeInteger">
				<annotation>
					<documentation>
						Id of the link from which this transition rule accepts vehicles.
					</documentation>
				</annotation>
			</element>
			<element name="sourceLaneIndex" type="nonNegativeInteger">
				<annotation>
					<documentation>
						Index of the incoming link's lane from which this transition rule accepts vehicles.
					</documentation>
				</annotation>
			</element>
			<element name="destinationLinkId" type="nonNegativeInteger">
				<annotation>
					<documentation>
						Id of the link to which this transition rule will guide vehicles.
					</documentation>
				</annotation>
			</element>
			<element name="destinationLaneIndex" type="nonNegativeInteger">
				<annotation>
					<documentation>
						Index of the outgoing link's lane to which this transition rule will guide vehicles.
					</documentation>
				</annotation>
			</element>
			<element name="BezierCurveGeometry" type="tns:CubicBezierCurve">
				<annotation>
					<documentation>
						Bezier curve that defines this transition rule trajectory shape.
					</documentation>
				</annotation>
			</element>
		</sequence>
	</complexType>

	<complexType name="OriginNode">
		<annotation>
			<documentation>
				Origin node is the node of the ru.cos.sim.visualizer.sim.road network
				from which vehicles starts their trips. It is the 
				point where vehicles originated.
				Only one outgoing link is allowed to be connected
				to the origin node.	
			</documentation>
		</annotation>
		<complexContent>
			<extension base="tns:Node">
				<sequence>
					<element name="outgoingLinkId" type="nonNegativeInteger">
						<annotation>
							<documentation>
								Id of the outgoing link.
							</documentation>
						</annotation>
					</element>
					<element name="CircleGeometry" type="tns:Circle">
						<annotation>
							<documentation>
								Geometry of origin node is represented as circle connected to
								the beginning of the only outgoing link.
							</documentation>
						</annotation>
					</element>
				</sequence>
			</extension>
		</complexContent>
	</complexType>

	<complexType name="Circle">
		<annotation>
			<documentation>
				Definition of the circle of specified radius on the plane.
			</documentation>
		</annotation>
		<sequence>
			<element name="Center" type="tns:Point" />
			<element name="radius" type="tns:positiveFloat" />
		</sequence>
	</complexType>

	<complexType name="DestinationNode">
		<annotation>
			<documentation>
				Destination node is the node of the ru.cos.sim.visualizer.sim.road network
				where vehicles finishes their trips. It is the 
				point where ru.cos.sim.visualizer.sim.vehicle ru.cos.sim.visualizer.sim.agents dies and are removed from the model.
				Only one incoming link is allowed to be connected
				to the destination node.	
			</documentation>
		</annotation>
		<complexContent>
			<extension base="tns:Node">
				<sequence>
					<element name="incomingLinkId" type="nonNegativeInteger">
						<annotation>
							<documentation>
								Id of the outgoing link.
							</documentation>
						</annotation>
					</element>
					<element name="CircleGeometry" type="tns:Circle">
						<annotation>
							<documentation>
								Geometry of destination node is represented as circle connected to
								the end of the only incoming link.
							</documentation>
						</annotation>
					</element>
				</sequence>
			</extension>
		</complexContent>
	</complexType>

	<complexType name="Origin">
		<annotation>
			<documentation>
				Origin is an agent that originates vehicles in the origin node.
				Origin creates instances of the vehicles, places them on the ru.cos.sim.visualizer.sim.road
				and revive them to live in simulation process.
				Origin generates external traffic flow from outside to the ru.cos.sim.visualizer.sim.road network
				model. In real life traffic flows may vary, origins allow to model variations
				of generated traffic flows.
				Behavior of the origin divided into one or more time periods. In each period
				origin generates traffic flow with uniform characteristics like traffic flow intensity,
				distribution of vehicles between destination nodes, distribution of vehicles between
				specific ru.cos.sim.visualizer.sim.vehicle types and other.
			</documentation>
		</annotation>
		<sequence>
			<element name="originNodeId" type="nonNegativeInteger">
				<annotation>
					<documentation>
						Id of the origin node from which this origin agent will generate traffic flow.
					</documentation>
				</annotation>
			</element>
			<element name="TimePeriods">
				<annotation>
					<documentation>
						List of origin time periods of uniform traffic flow generation.
					</documentation>
				</annotation>
				<complexType>
					<sequence>
						<element name="TimePeriod" type="tns:OriginTimePeriod"
							maxOccurs="unbounded" />
					</sequence>
				</complexType>
			</element>
		</sequence>
	</complexType>

	<complexType name="OriginTimePeriod">
		<annotation>
			<documentation>
				Definition of origin time period during which it will generate traffic
				flow with uniform characteristics.
			</documentation>
		</annotation>
		<sequence>
			<element name="duration" type="tns:positiveFloat">
				<annotation>
					<documentation>
						Duration of the period in seconds.
					</documentation>
				</annotation>
			</element>
			<element name="numberOfVehicles" type="nonNegativeInteger">
				<annotation>
					<documentation>
						Number of ru.cos.sim.visualizer.sim.vehicle that origin will try to originate during period.
						Intensity of traffic flow therefore will be equal to 3600*numberOfVehicles/duration [veh/hour].
						If it is impossible to move ru.cos.sim.visualizer.sim.vehicle on the ru.cos.sim.visualizer.sim.road (due to traffic jam, for example), then instance 
						of it will be placed in the queue and moved on the ru.cos.sim.visualizer.sim.road as soon as possible.
					</documentation>
				</annotation>
			</element>
			<element name="Destinations">
				<annotation>
					<documentation>
						Set of destinations with their probability weights.
						While originating new ru.cos.sim.visualizer.sim.vehicle it will be initialized with random destination node
						from this set. Probability of initializing one destination node or another will 
						depend on its weight, i.e. P(destId)=W(destId)/Sum(AllDestinationWeights).
					</documentation>
				</annotation>
				<complexType>
					<sequence>
						<element name="Destination" maxOccurs="unbounded">
							<complexType>
								<sequence>
									<element name="weight" type="nonNegativeInteger">
										<annotation>
											<documentation>
												Probability weight of a particular destination node.
											</documentation>
										</annotation>
									</element>
									<element name="destinationNodeId" type="nonNegativeInteger">
										<annotation>
											<documentation>
												Id of the destination node.
											</documentation>
										</annotation>
									</element>
								</sequence>
							</complexType>
						</element>
					</sequence>
				</complexType>
			</element>
			<element name="VehicleProfiles">
				<annotation>
					<documentation>
						Set of ru.cos.sim.visualizer.sim.vehicle profiles with their probability weights.
						While originating new ru.cos.sim.visualizer.sim.vehicle it will be initialized with random ru.cos.sim.visualizer.sim.vehicle profile parameters
						from this set. Probability of initializing one ru.cos.sim.visualizer.sim.vehicle profile or another will 
						depend on its weight, i.e. P(vehicleProfile)=W(vehicleProfile)/Sum(AllVehicleProfileWeights).
					</documentation>
				</annotation>
				<complexType>
					<sequence>
						<element name="VehicleProfile">
							<complexType>
								<sequence>
									<element name="weight" type="nonNegativeInteger">
										<annotation>
											<documentation>
												Probability weight of a particular ru.cos.sim.visualizer.sim.vehicle profile.
											</documentation>
										</annotation>
									</element>
									<choice>
										<annotation>
											<documentation>
												Set of possible ru.cos.sim.visualizer.sim.vehicle profiles (types).
											</documentation>
										</annotation>
										<element name="RegularVehicle" type="tns:RegularVehicle" />
									</choice>
								</sequence>
							</complexType>
						</element>
					</sequence>
				</complexType>
			</element>
		</sequence>
	</complexType>

	<complexType name="Vehicle">
		<annotation>
			<documentation>
				General ru.cos.sim.visualizer.sim.vehicle definition.
			</documentation>
		</annotation>
		<sequence>
			<element name="vehicleId" type="string">
				<annotation>
					<documentation>
						Unique ru.cos.sim.visualizer.sim.vehicle id in the simulation process.
						For example ru.cos.sim.visualizer.sim.vehicle's plate number.
					</documentation>
				</annotation>
			</element>
			<element name="length" type="tns:positiveFloat">
				<annotation>
					<documentation>
						Length of the ru.cos.sim.visualizer.sim.vehicle.
					</documentation>
				</annotation>
			</element>
			<element name="width" type="tns:positiveFloat">
				<annotation>
					<documentation>
						Width of the ru.cos.sim.visualizer.sim.vehicle.
					</documentation>
				</annotation>
			</element>
			<element name="class">
				<annotation>
					<documentation>
						Vehicle class.
						For now two ru.cos.sim.visualizer.sim.vehicle classes is allowed:
						Car and Truck. Car is lightweight automobile,
						Truck is a heavyweight ru.cos.sim.visualizer.sim.vehicle.
						Class of the ru.cos.sim.visualizer.sim.vehicle doesn't influence on ru.cos.sim.visualizer.sim.vehicle
						behavior, it is just for visualization purposes.
					</documentation>
				</annotation>
				<simpleType>
					<restriction base="string">
						<enumeration value="Car" />
						<enumeration value="Truck" />
					</restriction>
				</simpleType>
			</element>
		</sequence>
	</complexType>

	<complexType name="RegularVehicle">
		<annotation>
			<documentation>
				Regular ru.cos.sim.visualizer.sim.vehicle for now is the only concrete ru.cos.sim.visualizer.sim.vehicle type.
				Regular ru.cos.sim.visualizer.sim.vehicle has no additional properties compared to abstract 
				ru.cos.sim.visualizer.sim.vehicle data definition, except ru.cos.sim.visualizer.sim.driver. 
				I.e. regular ru.cos.sim.visualizer.sim.vehicle it is a ru.cos.sim.visualizer.sim.vehicle that drived by some ru.cos.sim.visualizer.sim.driver.
				For now only Composite Driver is allowed.
				Note: it is assumed that regular ru.cos.sim.visualizer.sim.vehicle passes ru.cos.sim.visualizer.sim.driver commands in terms of 
				acceleration and turn without any changes.
			</documentation>
		</annotation>
		<complexContent>
			<extension base="tns:Vehicle">
				<choice>
					<annotation>
						<documentation>
							Set of drivers allowed for Regular ru.cos.sim.visualizer.sim.vehicle.
							For now only CompositeDriver.
						</documentation>
					</annotation>
					<element name="CompositeDriver" type="tns:CompositeDriver" />
				</choice>
			</extension>
		</complexContent>
	</complexType>

	<complexType name="CompositeDriver">
		<annotation>
			<documentation>
				Composite ru.cos.sim.visualizer.sim.driver is the ru.cos.sim.visualizer.sim.driver model that
				compose set of different models of various aspects of ru.cos.sim.visualizer.sim.driver behavior
				(models like car-following, lane-changing, traffic light subjection and other)
				with the aim to achieve realistic behavior.
				In the current implementation of composite ru.cos.sim.visualizer.sim.driver more than 15 behavior models are composed.  
			</documentation>
		</annotation>
		<sequence>
			<element name="destinationNodeId" type="nonNegativeInteger">
				<annotation>
					<documentation>
						Driver's destination node id.
					</documentation>
				</annotation>
			</element>
			<element name="Route" minOccurs="0">
				<annotation>
					<documentation>
						Predefined route for the ru.cos.sim.visualizer.sim.driver.
						Route is specified as comma separated list of identifiers of the links in the route.
						For example, &lt;Route&gt;1,2,3,4,5&lt;/Route&gt;.
						Route must leads to the destination node, otherwise unexpected ru.cos.sim.visualizer.sim.exceptions will occur.
						When route for the ru.cos.sim.visualizer.sim.driver is specified by the &lt;Route&gt; element it will never change,
						ru.cos.sim.visualizer.sim.driver will follow them until it reaches destination.
						But &lt;Route&gt; is optional element. In case when it is not specified ru.cos.sim.visualizer.sim.driver instance will use 
						internal route assignment service that will operates on the principle of dynamic user equilibrium.
						In this case route may changes.
					</documentation>
				</annotation>
				<simpleType>
					<restriction base="string">
						<pattern value="[0-9]+(,[0-9]+)*" />
					</restriction>
				</simpleType>
			</element>
			<element name="Parameters">
				<annotation>
					<documentation>
						Parameters of the Composite Driver is a union of parameters of all
						composed behavior models.
						For now only three models requires parameters, they are:
						* IDM Car-following
						* MOBIL lane changing
						* One Lane Intersection
					</documentation>
				</annotation>
				<complexType>
					<sequence>
						<element name="maxSpeed" type="tns:positiveFloat" />
						<element name="maxAcceleration" type="tns:positiveFloat" />
						<element name="comfortDeceleration" type="tns:positiveFloat" />
						<element name="minDistance" type="tns:positiveFloat" />
						<element name="desiredHeadwayTime" type="tns:positiveFloat" />
						<element name="abruptness" type="tns:positiveFloat" />
						<element name="politeness" type="float" />
						<element name="accThreshold" type="tns:positiveFloat" />
						<element name="intersectionGapTime" type="tns:positiveFloat" />
					</sequence>
				</complexType>
			</element>
		</sequence>
	</complexType>

	<complexType name="RegularVehicleAgent">
		<annotation>
			<documentation>
				Definition of agent that is implemented by Regular ru.cos.sim.visualizer.sim.vehicle.
				Actually it is definition of Regular Vehicle instance + 
				its location and speed.
				Such predefined regular ru.cos.sim.visualizer.sim.vehicle agent will be placed on the ru.cos.sim.visualizer.sim.road network
				in the specified location and specified speed and will move right when 
				simulation starts (contrary to ru.cos.sim.visualizer.sim.vehicle generated by origins)
			</documentation>
		</annotation>
		<complexContent>
			<extension base="tns:RegularVehicle">
				<group ref="tns:LocationAndSpeed">
					<annotation>
						<documentation>
							Defining particular ru.cos.sim.visualizer.sim.vehicle location and speed.
						</documentation>
					</annotation>
				</group>
			</extension>
		</complexContent>
	</complexType>

	<group name="LocationAndSpeed">
		<annotation>
			<documentation>
				Defining particular ru.cos.sim.visualizer.sim.vehicle location and speed.
			</documentation>
		</annotation>
		<sequence>
			<choice>
				<element name="LinkLocation" type="tns:LinkLocation" />
				<element name="NodeLocation" type="tns:NodeLocation" />
			</choice>
			<element name="speed" type="tns:positiveFloat" />
		</sequence>
	</group>

	<complexType name="Location">
		<annotation>
			<documentation>
				Abstract location consists of position and shift.
			</documentation>
		</annotation>
		<sequence>
			<element name="position" type="tns:positiveFloat" minOccurs="0">
				<annotation>
					<documentation>
						Position on the trajectory (lane or transition rule).
					</documentation>
				</annotation>
			</element>
			<element name="shift" type="float" minOccurs="0">
				<annotation>
					<documentation>
						Shift from the trajectory (lane or transition rule).
						Shift is a misplacement of the object away from the trajectory.
						Shift is the distance between object's location and trajectory.
						Shift on left side is negative, on right is positive.
					</documentation>
				</annotation>
			</element>
		</sequence>
	</complexType>

	<complexType name="LinkLocation">
		<annotation>
			<documentation>
				Link location.
			</documentation>
		</annotation>
		<complexContent>
			<extension base="tns:Location">
				<sequence>
					<element name="linkId" type="nonNegativeInteger" />
					<element name="segmentId" type="nonNegativeInteger"
						minOccurs="0" />
					<element name="laneIndex" type="nonNegativeInteger"
						minOccurs="0" />
				</sequence>
			</extension>
		</complexContent>
	</complexType>

	<complexType name="NodeLocation">
		<annotation>
			<documentation>
				Node location.
			</documentation>
		</annotation>
		<complexContent>
			<extension base="tns:Location">
				<sequence>
					<element name="nodeId" type="nonNegativeInteger" />
					<element name="transitionRuleId" type="nonNegativeInteger"
						minOccurs="0" />
				</sequence>
			</extension>
		</complexContent>
	</complexType>

	<complexType name="TrafficLightNetwork">
		<annotation>
			<documentation>
				Abstract definition of the traffic light network.
			</documentation>
		</annotation>
		<sequence>
			<element name="regularNodeId" type="nonNegativeInteger">
				<annotation>
					<documentation>
						Id of a regular node on which traffic light network is located.
					</documentation>
				</annotation>
			</element>
			<element name="TrafficLights">
				<annotation>
					<documentation>
						Set of traffic lights of this TLN.
					</documentation>
				</annotation>
				<complexType>
					<sequence>
						<element name="TrafficLight" type="tns:TrafficLight"
							maxOccurs="unbounded" />
					</sequence>
				</complexType>
			</element>
		</sequence>
	</complexType>

	<complexType name="TrafficLight">
		<annotation>
			<documentation>
				Definition of the traffic light.
				Traffic light here is, actually, an abstraction,
				i.e. it generalize all real traffic lights which signals are 
				always equals and switched synchronously.
				For example, for two real traffic lights that controls opposite
				traffic flows in the intersection will correspond on traffic light definition,
				because signals of such opposite traffic lights are always the same.
				So with the perspective of traffic light switching schedule it will be one 
				traffic light - that simplifies configuration of TL schedules
				The only difference of this traffic lights are their locations or placements,
				thats why for traffic light definition it is required  &lt;Placement&gt; element
				that specifies where this TL is observed.				
			</documentation>
		</annotation>
		<sequence>
			<element name="id" type="nonNegativeInteger">
				<annotation>
					<documentation>
						Unique traffic light id in the node.
					</documentation>
				</annotation>
			</element>
			<element name="name" type="string" minOccurs="0">
				<annotation>
					<documentation>
						Human readable name of the traffic light.
					</documentation>
				</annotation>
			</element>
			<element name="Placement">
				<annotation>
					<documentation>
						Placement element specifies where this traffic light will be visible,
						i.e. which transition rules it controls.
						Basically, traffic light can be placed on the particular transition rule
						on the specified position or on the entire TurnTRGroup.
						In case of TurnTRGroup traffic light will be placed always in the beginning
						of group's transition rules.
					</documentation>
				</annotation>
				<complexType>
					<choice maxOccurs="unbounded">
						<element name="turnTRGroupId" type="nonNegativeInteger">
							<annotation>
								<documentation>
									Turn Transition Rules Group id on which traffic will be placed. 
								</documentation>
							</annotation>
						</element>
						<element name="TransitionRule">
							<annotation>
								<documentation>
									Specific transition rule id and position on it where traffic light will be placed. 
								</documentation>
							</annotation>
							<complexType>
								<sequence>
									<element name="transitionRuleId" type="nonNegativeInteger" />
									<element name="position" type="tns:nonNegativeFloat" />
								</sequence>
							</complexType>
						</element>
					</choice>
				</complexType>
			</element>
		</sequence>
	</complexType>

	<complexType name="RegularTrafficLightNetwork">
		<annotation>
			<documentation>
				Regular traffic light network is a simplest traffic light network
				that obeys predefined schedule of traffic light signal switching.
			</documentation>
		</annotation>
		<complexContent>
			<extension base="tns:TrafficLightNetwork">
				<sequence>
					<element name="scheduleTimeShift" type="tns:nonNegativeFloat"
						minOccurs="0">
						<annotation>
							<documentation>
								Time shift of the beginning of schedule of traffic light switching.
								Moments of traffic light signals switching will be shifted in time
								on the specified amount in seconds.
							</documentation>
						</annotation>	
					</element>
					<element name="Schedule" type="tns:ScheduleTable">
						<annotation>
							<documentation>
								Traffic lights signals switching schedule.
							</documentation>
						</annotation>	
					</element>
				</sequence>
			</extension>
		</complexContent>
	</complexType>

	<complexType name="ScheduleTable">
		<annotation>
			<documentation>
				Simple traffic lights signals switching schedule.
				Schedule consists of set of time periods, for each time
				period it is specified signal for each traffic light.
				If signal is not specified it means that traffic light
				does not switch its signal and remains the same as on previous period.
				When time exceeds sum of time periods, then schedule repeats from the beginning.
			</documentation>
		</annotation>
		<sequence>
			<element name="TimePeriods">
				<annotation>
					<documentation>
						Set of time periods durations.
					</documentation>
				</annotation>
				<complexType>
					<sequence>
						<element name="TimePeriod" maxOccurs="unbounded">
							<complexType>
								<sequence>
									<element name="duration" type="tns:positiveFloat">
										<annotation>
											<documentation>
												Duration of the time period.
											</documentation>
										</annotation>
									</element>
									<element name="TrafficLightSignal" maxOccurs="unbounded" minOccurs="0">
										<complexType>
											<sequence>
												<element name="trafficLightId" type="nonNegativeInteger" />
												<element name="signal" type="tns:TrafficLightSignal"/>
											</sequence>
										</complexType>
									</element>
								</sequence>
							</complexType>
						</element>
					</sequence>
				</complexType>
			</element>
		</sequence>
	</complexType>

	<simpleType name="TrafficLightSignal">
		<annotation>
			<documentation>
				Set of allowed traffic light signals.
			</documentation>
		</annotation>
		<restriction base="string">
			<enumeration value="Red" />
			<enumeration value="Yellow" />
			<enumeration value="Green" />
		</restriction>
	</simpleType>

	<complexType name="PeakAwareTrafficLightNetwork">
		<annotation>
			<documentation>
				Peak Aware Traffic Light Network knows about peak or rush hours and has 
				alternate schedule of traffic light switching for this period.
			</documentation>
		</annotation>
		<complexContent>
			<extension base="tns:TrafficLightNetwork">
				<sequence>
					<element name="scheduleTimeShift" type="tns:nonNegativeFloat"
						minOccurs="0">
						<annotation>
							<documentation>
								Time shift of the beginning of schedule of traffic light switching.
								Moments of traffic light signals switching will be shifted in time
								on the specified amount in seconds.
							</documentation>
						</annotation>	
					</element>
					<element name="PeakPeriod">
						<annotation>
							<documentation>
								Peak period definition.
							</documentation>
						</annotation>
						<complexType>
							<sequence>
								<element name="startTime" type="tns:positiveFloat" />
								<element name="duration" type="tns:positiveFloat" />
							</sequence>
						</complexType>
					</element>
					<element name="RegularSchedule" type="tns:ScheduleTable" />
					<element name="PeakSchedule" type="tns:ScheduleTable" />
				</sequence>
			</extension>
		</complexContent>
	</complexType>

	<complexType name="Meter">
		<annotation>
			<documentation>
				General definition of the meter in the simulation process.
				Meters framework in COS.SIM has very generalized architecture that
				allows to configure data collection in various ways.
				Any meter may operate in five separate data collection modes:
				* measure instant value
				* measure average value
				* collect value's history
				* measure and collect average values on several specified time periods
				* measure and collect value's history on several specified time periods
				Meters Framework is based on the assumption that each meter in each time
				moment measures some instant value.
			</documentation>
		</annotation>
		<sequence>
			<element name="id" type="nonNegativeInteger">
				<annotation>
					<documentation>
						Unique meter id.
					</documentation>
				</annotation>
			</element>
			<element name="name" type="string" minOccurs="1">
				<annotation>
					<documentation>
						Human readable name of the meter.
					</documentation>
				</annotation>
			</element>
			<element name="DataCollectionModes">
				<annotation>
					<documentation>
						Definitions of data collection modes.
					</documentation>
				</annotation>
				<complexType>
					<sequence>
						<element name="AverageDataMode" minOccurs="0">
							<annotation>
								<documentation>
									Average data collection mode. Requires no parameters.
									It will just measure average value from the beginning of the simulation.
								</documentation>
							</annotation>
							<complexType>
								<sequence></sequence>
							</complexType>
						</element>
						<element name="HistoryDataMode" minOccurs="0">
							<annotation>
								<documentation>
									History data collection mode requires frequency of value recording,
									such frequency is defined by logInterval parameter.
									In this mode meter will record instant value one time per logInterval seconds.
								</documentation>
							</annotation>
							<complexType>
								<sequence>
									<element name="logInterval" type="tns:positiveFloat" />
								</sequence>
							</complexType>
						</element>
						<element name="ScheduledAverageDataMode">
							<annotation>
								<documentation>
									Scheduled Average Data collection mode requires schedule,
									i.e. set of time periods for which to gather average value.
								</documentation>
							</annotation>
							<complexType>
								<sequence>
									<element name="Schedule" type="tns:MeterShedule" />
								</sequence>
							</complexType>
						</element>
						<element name="ScheduledHistoryDataMode">
							<annotation>
								<documentation>
									Scheduled History Data collection mode requires schedule and
									logInterval parameters.
									In this mode meter will gather history of value for each of specified time period.
								</documentation>
							</annotation>
							<complexType>
								<sequence>
									<element name="logInterval" type="tns:positiveFloat" />
									<element name="Schedule" type="tns:MeterShedule" />
								</sequence>
							</complexType>
						</element>
					</sequence>
				</complexType>
			</element>
		</sequence>
	</complexType>

	<complexType name="MeterShedule">
		<annotation>
			<documentation>
				Meter schedule. It is just a set of time periods.
			</documentation>
		</annotation>
		<sequence>
			<element name="TimePeriod" maxOccurs="unbounded">
				<complexType>
					<sequence>
						<element name="from" type="tns:positiveFloat" />
						<element name="to" type="tns:positiveFloat" />
					</sequence>
				</complexType>
			</element>
		</sequence>
	</complexType>

	<complexType name="TrafficVolumeMeter">
		<annotation>
			<documentation>
				Traffic Volume Meter measures cumulative number of vehicles that crosses 
				specified position on the link.
			</documentation>
		</annotation>
		<complexContent>
			<extension base="tns:Meter">
				<sequence>
					<element name="linkId" type="nonNegativeInteger" />
					<element name="segmentId" type="nonNegativeInteger" />
					<element name="position" type="tns:positiveFloat" />
				</sequence>
			</extension>
		</complexContent>
	</complexType>

	<complexType name="InstantAverageSpeedMeter">
		<annotation>
			<documentation>
				Instant Average Speed Meter measures average instant speed of all vehicles in the model.
			</documentation>
		</annotation>
		<complexContent>
			<extension base="tns:Meter">
			</extension>
		</complexContent>
	</complexType>

	<complexType name="NetworkAverageTravelSpeedMeter">
		<annotation>
			<documentation>
				Network Average Travel Speed Meter measures average travel speed of all vehicles
				that appears on the model for current time, i.e. average value among all vehicles
				that already reaches their destination and disappears with summary of all vehicles
				that are currently on the ru.cos.sim.visualizer.sim.road.
				Travel Speed of the ru.cos.sim.visualizer.sim.vehicle equals to currentTravelledDistance/currentTravelTime.
			</documentation>
		</annotation>
		<complexContent>
			<extension base="tns:Meter">
			</extension>
		</complexContent>
	</complexType>

	<complexType name="TotalTravelTimeMeter">
		<annotation>
			<documentation>
				Total Travel Time Meter measures sum of travel time of vehicles that
				are currently on the ru.cos.sim.visualizer.sim.road and that are already reached their destinations.
			</documentation>
		</annotation>
		<complexContent>
			<extension base="tns:Meter">
			</extension>
		</complexContent>
	</complexType>

	<complexType name="AverageTravelTimeMeter">
		<annotation>
			<documentation>
				Average Travel Time Meter measures average travel time among vehicles that
				are currently on the ru.cos.sim.visualizer.sim.road and that are already reached their destinations.
			</documentation>
		</annotation>
		<complexContent>
			<extension base="tns:Meter">
			</extension>
		</complexContent>
	</complexType>

	<complexType name="LinkAverageTravelSpeedMeter">
		<annotation>
			<documentation>
				Link Average Travel Speed Meter measures average travel speed of vehicles on this link.
			</documentation>
		</annotation>
		<complexContent>
			<extension base="tns:Meter">
				<sequence>
					<element name="linkId" type="nonNegativeInteger" />
				</sequence>
			</extension>
		</complexContent>
	</complexType>

	<complexType name="SectionAverageTravelSpeedMeter">
		<annotation>
			<documentation>
				Section Average Travel Speed Meter measures average travel speed of vehicles on specified link's section.
				Section of the link is specified as its _end_ and length of the section, therefore, to find start of the section
				you must to moves back on the link on the distance equal to section length.
			</documentation>
		</annotation>
		<complexContent>
			<extension base="tns:Meter">
				<sequence>
					<element name="linkId" type="nonNegativeInteger" />
					<element name="segmentId" type="nonNegativeInteger" />
					<element name="position" type="tns:positiveFloat" />
					<element name="sectionLength" type="tns:positiveFloat">
						<annotation>
							<documentation>
								Be aware! Section length is measured in the backward direction of the link. 
							</documentation>
						</annotation>
					</element>
				</sequence>
			</extension>
		</complexContent>
	</complexType>

	<complexType name="DensityMeter">
		<annotation>
			<documentation>
				Density Meter measures vehicles density on a specified link's section.
				Section of the link is specified as its _end_ and length of the section, therefore, to find start of the section
				you must to moves back on the link on the distance equal to section length.
			</documentation>
		</annotation>
		<complexContent>
			<extension base="tns:Meter">
				<sequence>
					<element name="linkId" type="nonNegativeInteger" />
					<element name="segmentId" type="nonNegativeInteger" />
					<element name="position" type="tns:positiveFloat" />
					<element name="sectionLength" type="tns:positiveFloat">
						<annotation>
							<documentation>
								Be aware! Section length is measured in the backward direction of the link. 
							</documentation>
						</annotation>
					</element>
				</sequence>
			</extension>
		</complexContent>
	</complexType>

	<complexType name="FlowMeter">
		<annotation>
			<documentation>
				Flow Meter measures intensity of the traffic flow through a specified position on the link.
				Additional parameter of the meter is a measuringTime, that defines on which time span
				traffic intensity value should be calculated. 
			</documentation>
		</annotation>
		<complexContent>
			<extension base="tns:Meter">
				<sequence>
					<element name="linkId" type="nonNegativeInteger" />
					<element name="segmentId" type="nonNegativeInteger" />
					<element name="position" type="tns:positiveFloat" />
					<element name="measuringTime" type="tns:positiveFloat" />
				</sequence>
			</extension>
		</complexContent>
	</complexType>

	<complexType name="DensityFlowMeter">
		<annotation>
			<documentation>
				Density Flow Meter Flow, actually, it is a combination of the Density and Flow meters
				that acts together. Parameters for this meter is the union of parameters of density and flow meters. 
			</documentation>
		</annotation>
		<complexContent>
			<extension base="tns:Meter">
				<sequence>
					<element name="linkId" type="nonNegativeInteger" />
					<element name="segmentId" type="nonNegativeInteger" />
					<element name="position" type="tns:positiveFloat" />
					<element name="sectionLength" type="tns:positiveFloat" />
					<element name="measuringTime" type="tns:positiveFloat" />
				</sequence>
			</extension>
		</complexContent>
	</complexType>

	<complexType name="VehiclesAppearanceHeadwayMeter">
		<annotation>
			<documentation>
				Vehicles Appearance Headway Meter measures time headways between vehicles appearance
				in specified position of the link. Data about headways is gathered to plot histogram
				and meter requires additional timeBinLength parameter - width of the bar in the histogram.
			</documentation>
		</annotation>
		<complexContent>
			<extension base="tns:Meter">
				<sequence>
					<element name="timeBinLength" type="tns:positiveFloat" />
					<element name="linkId" type="nonNegativeInteger" />
					<element name="segmentId" type="nonNegativeInteger" />
					<element name="position" type="tns:positiveFloat" />
				</sequence>
			</extension>
		</complexContent>
	</complexType>

	<simpleType name="positiveFloat">
		<restriction base="float">
			<minExclusive value="0" />
		</restriction>
	</simpleType>

	<simpleType name="nonNegativeFloat">
		<restriction base="float">
			<minInclusive value="0" />
		</restriction>
	</simpleType>

	<simpleType name="referenceId">
		<restriction base="integer">
			<minInclusive value="-1" />
		</restriction>
	</simpleType>

</schema>